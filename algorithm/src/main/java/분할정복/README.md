# 분할정복

- 문제를 분할하고, 각각을 정복해나가는 알고리즘
- 큰 문제를 작은 단위로 쪼갠 뒤, 그 작은 단위에서 해결한 답을 가지고 이를 결합하여 최종 답을 해결해 나갈 수 있는 기법이다.
- 이를 작게 분할하여 문제를 해결해나가는 과정을 **재귀**를 사용하여 해결하고, 이를 결합하여 답을 찾아낼 수 있다.

> 아직 DP를 제대로 공부해보진 않았지만 작은 단위로 분할하여 접근하는 방식에서는 비슷한 부분이 있다고 한다.

>기초 알고리즘과 자료구조를 공부해본 뒤, DP에 대해 공부할 때 다시 비교해서 찾아보도록 하겠다.

## **분할정복 알고리즘 탐색과정**

이 프로세스는 작게 분할한 문제가 직접 해결 가능할 만큼 충분히 작아질 때까지 재귀적으로 계속된다.

일반적으로 분할정복 알고리즘은 다음 세 단계로 구성된다.

1. **분할**: 문제를 작은 하위 문제로 분할.
2. **정복**: 각 하위 문제는 재귀적으로 해결.
3. **결합**: 하위 문제의 해결책을 결합하여 원래 문제를 해결.

# 문제 풀이

## boj_24460 특별상이라도 받고 싶어

- 사실상 집중이 너무 안되서 오래 걸린문제..
- 대략 어떤식으로 풀어나갈지는 감이 잡혔지만 재귀 함수로 구현했을 때, 어떻게 구현해야할지 고민이 많았다 !
- 처음에는 단순히 (x, y), (x + k, y), (x, y + k), (x + k, y + k)라는 재귀를 순서대로 호출하면 되지 않을까?라는 막연한 생각으로 시작했지만.. 어떤 값을 종료기준에 리턴해줘야할 지 고민을 많이 했다.
- 결론적으로는 4개로 나눴을 때, 각 나눈 파트의 2번째로 작은 값을 리턴해나가는 방식으로 적용하여 풀었다.
  - 배열을 매 파트마다 새로 생성하여 주어야한다.
  - 처음에 static으로 두고 했다가, 값이 변경되는 것을 파악하고 바로 메서드 안에 새로운 객체를 선언해주는 방식으로 적용했더니 풀렸다 !
- 각 파트별로 두번째로 작은 수를 리턴해주다보면 마지막 가장 큰 4개의 영역에 모여진 두번째 작은 수들이 모여 값을 리턴하게 된다.

## boj_17829 222-풀링

- 이 문제도 특별상 문제와 비슷한 문제 유형이었다.
- 기본적으로 각 영역에 대해 작게 분할하고, 분할한 영역에 대해 재귀를 사용하여 문제를 해결하고, 해결한 답을 결합하여 문제가 해결되는 방식으로 풀 수 있었다.

### 접근 방식

- 처음에는 단순히 작게 분할하는 의미에서 생각하다보니 분할한 뒤, 2번째로 큰 수를 어떻게 다시 새로운 2차원 리스트에 저장하지?라는 생각을 했다.
  - 단순히 분할하고 2번째로 큰수 계산하고, 리턴한 이 값을 어디에 저장하지?라는 막연한 생각을 했다….
- 하지만, 이는 잘못된 생각이라는 걸 나중에 파악했다. 결론적으로 말하면 각 분할된 내용에서 해결한 값들을 결합하다보면 작은 단위에 대한 두번째로 큰 수가 나오게 된다는 것을 깨닫지 못했던 것이었다.
  - 예를 들자면 4 * 4에 대한 문제라고 생각했을 때, 각각의 값을 다시 2 * 2 리스트에 저장하여 다시 쪼갠 뒤, 두번째로 큰값을 찾는.. 이런 방식으로 생각을 했었다.
  - 하지만 4 * 4에서 2 * 2로 쪼개진 값들의 2번째로 큰 수들을 리턴하고, 이 수들을 (x,y),(x + k, y),(x, y+k), (x+k, y+k)에 대해 2번째로 큰 수들을 모은다.
    이 결합된 수들을 바탕으로 다시 2번째로 큰 수를 구하면 우리가 구하고자 하는 답이 나오게 된다..

### 회고

- 바보처럼 이 부분에 대해 생각하지 못하고, 보이는 그대로 연산해나가려고 하다보니 분할정복을 어떻게 해야할지, 재귀를 어떻게 사용해서 구현해야할지 고민을 많이 했다..
- 분할 정복 유형을 더 많이 풀어보면서 감을 더 잡아가야겠다는 생각을 하게된 문제였다… 결론적으로는 어제 풀었던 문제와 비슷했던 유형이였다……


## boj_18222
- 하루동안 고민했지만 결국 못풀었다..ㅠㅠ
- 처음에는 단순히 규칙대로 재귀를 호출하여 문자열에 담고 입력값 k번째 수를 반환하려고 했었다.
- 하지만 입력값이 무려 10의 8제곱이나 되었고, 이를 문자열로 다 저장한다는 것은 말도 안돤디고 생각하면서 다시 한번 풀이법을 고민하게 되었다.
- 그러나... 결국 답을 찾지 못해 해설을 찾아보게 되었다.

### 접근 방식
- 접근 방식은 다음과 같았다.
- 우선 k값을 받아 문자열 X에 대한 규칙을 찾아서, k값을 최소한으로 쪼갠 뒤, 그에 해당하는 0 또는 1을 반환하게 하면 되는 방식이었다.
- k가 13이라고 했을 떄, 2의 제곱으로 k보다 크면서 가장 작은 수인 16에서 시작한다.
- 여기에서 16은 x = "0110100110010110"에 해당한다.
- 이를 반을 쪼갠 뒤, k값에서 반을 쪼갠 인덱스만큼 빼주면 대칭 관계로써, 0이라면 1, 1이라면 0이라는 값을 찾게 된다.
  - 1 -> 0, 0 -> 1이라는 값으로 답과 반대인 값을 호출해야만 답을 구할 수 있다.
- 여기서 한번 더 반을 쪼갠 뒤 (위에서 k - 반으로 쪼갠 인덱스)를 다시 뺴주면 이는 또다시 대칭 관계로 인해 0 <-> 1 관계로써 값을 구할 수 있다.
  - 즉, 여기서는 다시 0 -> 0, 1 -> 1이라는 원래 값을 구하게 되는 것이다. 
- 이러한 규칙을 적용해보면 대략 아래와 같은 흐름으로 함수를 구현할 수 있었다.
- 우선 index라는 리스트에 2의 거듭제곱의 값을 저장해준다. - 64개의 배열로 저장하여 10의 18 제곱 입력값 제한 조건 만족
- func(long k)
  - 만약  k = 1이라면 0이 반환
  - index[0]부터 돌면서 k값보다 크면서 index에서 가장 작은 수를 찾게 되면, 여기에서부터 위의 접근 방식을 적용해나간다.
    - 최종적으로 /2씩 해주다보면 0 또는 1로 값이 호출될 것인데, 여기서 1이라는 값이 나오게 하기 위해서는 1 - func(k - index[i-1])로 정의하여 표현해줄 수 있따.
- 위와 같이 재귀를 통해 함수를 구현해주면 답을 구할 수 있다!

### 회고
- 이번 문제는 분할정복이라는 알고리즘 카테고리를 모르고 풀었다면 접근하지 못했을 것 같았다..
- 아직 재귀나 분할정복에 대한 문제를 많이 풀어보며 유형을 많이 풀어봐야겠다는 생각을 하게 되었다.
- 특히, 1 - func을 통해 리턴해주는 방식은 생각해보지 못한 방법이다보니,, 해답을 찾아보지 못했다면 못풀었을 것 같다...
- 더 열심히 공부해야겠다 !!!!